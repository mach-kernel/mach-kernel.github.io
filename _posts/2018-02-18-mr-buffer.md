---
title: How to write a text editor for a 31 year old computer
published: false
layout: post
categories: retro
date: 2018-02-18gT23:48:53.000Z
---

The Apple IIgs came out on September 15, 1986. It featured an absolutely earth-shattering 2.8 MHz WDC 65816 CPU (the same one that powered the SNES and other similar computers of that era, a 16-bit CPU with 24-bit addressing), 256k or 1MB RAM (upgradable to 8 MB), and an Ensoniq 8-bit stereo synth (which was a welcome upgrade from the bit-speaker of the Apple II family). The original Apple II family was built around the 6502 (8 bit, 16-bit addressing): it was designed to use console-interactive applications via ProDOS, or games that had their own custom rendering stacks built from scratch. In contrast, GS shipped with GS/OS, an operating system built to use the new computer's more powerful hardware. Booting the GS off of its system disk brought you to a GUI and not a console prompt. It would be misleading to omit mention of the [Apple built GUI](http://toastytech.com/guis/a2desk.html) for the Apple II family, however this compared to GS/OS is more of an afterthought. This was the first consumer-first computer that Apple shipped with _intent_ to provide a graphical user experience (other than the Lisa, but that computer was primarily marketed to businesses) to the everyman. This article is going to walk through, start to finish, how to build a text editor for this machine. 

### What do we have to work with?

At the beginning of this project I imposed a few requirements. My text editor should:

- Be launchable from GS/OS regardless of whether or not it actually runs windowed in the operating system.
- Not occupy more than 256k of RAM, so that it may run on _any_ IIgs.
- Run in native 16-bit mode.

If you are unfamiliar with this processor, then the last bulletpoint is confusing. By the time the IIgs had launched, there was already a plethora of software out in the wild that was compatible with the original Apple II (which used the 6502). The 65816 has an "emulation mode" that can be toggled which effectively turns the '816 into a 6502 by selectively "halving" the width of its accumulator and index registers (amongst some other things, which we will cover later).

GS/OS is a 16-bit co-operatively multitasked operating system. For me, this means that my text editor is going to be the only running program on the system after it finishes loading. The OS will remain in RAM but I will have to abstain from writing to certain memory locations in order to not corrupt the OS code. GS/OS will bootstrap my program and then pass complete control of the computer to it. To quit the application, I have to jump (`jsl` in native mode) to the entry point of the OS where it will then take over. 

Insofar as programming environment our options look kind of bleak:

- [ORCA/C](https://github.com/byteworksinc/ORCA-C), ANSI C compiler, but must run on bare metal or emulator.
- [cc65](https://github.com/cc65/cc65), ANSI C compiler, but only for 6502.
- [Merlin16](https://en.wikipedia.org/wiki/Merlin_(assembler), a 65816 assembler, but must run on bare metal or emulator.
- [Merlin32](https://www.brutaldeluxe.fr/products/crossdevtools/merlin/), a Merlin16 macro compatible assembler that runs on any modern computer that can build it from source.

I own a physical IIgs, but wanted to be able to develop easily from my computer. Furthermore, building _inside_ of an emulator is also clunky and not something that can easily be automated with a build script, so the only viable option was to use Merlin32. Additionally, the only way for me to really deploy things to the physical computer is by air-gapping a CF card to my desktop which is the only computer here with a multi-card reader. After deciding on Merlin32, the first order of business was to [write POSIX fs bindings](https://github.com/mach-kernel/cadius) for the BrutalDeluxe imaging tool, since it only ran on Windows, which is some kind of cardinal sin. Judicious use of `#pragma once` and some `stat()` had me making Apple II disk images from any popular `*nix` flavor. It was _finally_ time to get some programming done.