---
title: How to write a text editor for a 31 year old computer
published: false
layout: post
categories: retro
date: 2018-02-18gT23:48:53.000Z
---

The Apple IIgs came out on September 15, 1986. It featured an absolutely earth-shattering 2.8 MHz WDC 65816 CPU (the same one that powered the SNES and other similar computers of that era, a 16-bit CPU with 24-bit addressing), 256k or 1MB RAM (upgradable to 8 MB), and an Ensoniq 8-bit stereo synth (which was a welcome upgrade from the bit-speaker of the Apple II family). The original Apple II family was built around the 6502 (8 bit, 16-bit addressing): it was designed to use console-interactive applications via ProDOS, or games that had their own custom rendering stacks built from scratch. In contrast, GS shipped with GS/OS, an operating system built to use the new computer's more powerful hardware. Booting the GS off of its system disk brought you to a GUI and not a console prompt. It would be misleading to omit mention of the [Apple built GUI](http://toastytech.com/guis/a2desk.html) for the Apple II family, however this compared to GS/OS is more of an afterthought. This was the first consumer-first computer that Apple shipped with _intent_ to provide a graphical user experience (other than the Lisa, but that computer was primarily marketed to businesses) to the everyman. This article is going to walk through, start to finish, how to build a text editor for this machine. 

### What do we have to work with?

At the beginning of this project I imposed a few requirements. My text editor should:

- Be launchable from GS/OS regardless of whether or not it actually runs windowed in the operating system.
- Not occupy more than 256k of RAM, so that it may run on _any_ IIgs.
- Run in native 16-bit mode.

If you are unfamiliar with this processor, then the last bulletpoint is confusing. By the time the IIgs had launched, there was already a plethora of software out in the wild that was compatible with the original Apple II (which used the 6502). The 65816 has an "emulation mode" that can be toggled which effectively turns the '816 into a 6502 by selectively "halving" the width of its accumulator and index registers (amongst some other things, which we will cover later).

GS/OS is a 16-bit co-operatively multitasked operating system. For me, this means that my text editor is going to be the only running program on the system after it finishes loading. The OS will remain in RAM but I will have to abstain from writing to certain memory locations in order to not corrupt the OS code. GS/OS will bootstrap my program and then pass complete control of the computer to it. To quit the application, I have to jump (`jsl` in native mode) to the entry point of the OS where it will then take over. 

Insofar as programming environment our options look kind of bleak:

- [ORCA/C](https://github.com/byteworksinc/ORCA-C), ANSI C compiler, but must run on bare metal or emulator.
- [cc65](https://github.com/cc65/cc65), ANSI C compiler, but only for 6502.
- [Merlin16](https://en.wikipedia.org/wiki/Merlin_(assembler)), a 65816 assembler, but must run on bare metal or emulator.
- [Merlin32](https://www.brutaldeluxe.fr/products/crossdevtools/merlin/), a Merlin16 macro compatible assembler that runs on any modern computer that can build it from source.

I own a physical IIgs, but wanted to be able to develop easily from my computer. Furthermore, building _inside_ of an emulator is also clunky and not something that can easily be automated with a build script (i.e. it is not a good use of time to hack the emulator such that I can script UI actions), so the only viable option was to use Merlin32. Additionally, the only way for me to really deploy things to the physical computer is by air-gapping a CF card to my desktop which is the only computer here with a multi-card reader. After deciding on Merlin32, the first order of business was to figure out how to write disk images with my program such that an emulator could load it. I had to [write POSIX fs bindings](https://github.com/mach-kernel/cadius) for the BrutalDeluxe imaging tool, since it only ran on Windows, which is some kind of cardinal sin. Judicious use of `#pragma once` and some `stat()` had me making Apple II disk images from any popular `*nix` flavor. It was _finally_ time to get some programming done.

### The journey of COUT

The only way to not lose your mind with difficult projects is to try to write your software in as much of a goal-oriented manner as possible. The _bare minimum_ feature that _any_ editor must be able to implement is the display of strings on screen. In most programming languages, you can invoke some variant of `print()` to accomplish this task. In Apple II world, we do not have this affordance, although this is somewhat a lie since the Apple II ROM contains a series of toolbox functions that implement `COUT`, `RDKEY` and numerous other utilities. The workflow for toolbox utilities is simple: you prepare the registers with some data (in the case of `COUT`, a character is loaded to the `A` register, called the "accumulator"), `jsr` to the routine from your program, it performs some arbitrary task, and then invokes `rts` to return control to your code. This seems to be exactly what we would want, so why can't we use it?

It is time to learn a little bit about Apple IIgs memory architecture.

![iigsmemmap](https://i.imgur.com/K2wCCDW.png)

GS/OS executable files are stored in OMF, a relocatable executable format. If you've written software for Linux and/or Windows, then this is something analog to your `ELF` or `PE32` executable formats, but for the GS operating system. Regardless, it's important to note that the binary we are to produce is _relocatable_. This means that the operating system can arbitrarily load your code anywhere in free built-in or auxiliary RAM. Observe that each chunk of memory flows `$FFFF->$0000`, but more explicitly, that the memory is divided into 64k chunks. Bank `$00` is special ([also for hardware reasons best explained here](https://retrocomputing.stackexchange.com/questions/52/how-do-i-use-shadowed-memory-to-render-super-hi-res-quickly), but we are skipping this for today), as it contains access to the computer's ROM. Below is a diagram of the bank `$00` layout.

![bank0](https://i.imgur.com/OHRysCb.png)

Since our GS/OS code is relocatable, you _do not have any guarantee_ that your program will consistently load at the same location (even moreso given the variety of aux memory configurations your end user may possibly have). Recall that earlier we spoke about using `jsr` (with a 16-bit immediate address argument of the location of the routine) to invoke the toolbox's `COUT` after loading a character. Behind the scenes, the `jsr` instruction places the memory location of the next instruction in line (i.e. `PC+1`) onto the stack before jumping to the address you specified as an immediate argument. The `rts` instruction (what you use to exit from the routine) knows where to go back by pulling the value `jsr` pushed onto the stack. That value is a 16-bit address, which means that this whole exercise will not work unless your program is in bank 0.

The observant reader will exclaim that the 65816 supports 24 bit addressing, so specifying the bank is not a problem. This is correct, however we need to learn more about the ROM to understand why exactly this won't work. To retain compatibility with existing Apple II software, the original Apple II ROM must ship with the IIgs such that software written the Apple II can still run. That is, if original Apple II programs use the COUT routine, they will also need to use it on the IIgs regardless of the 6502 emulation mode. Therefore, these ROM functions are written in 6502 assembly as opposed to native 65816 assembly, which poses two problems. Suppose we invoke a `jsl $00FDED`, with the 24-bit "long" address of the `COUT` routine. The computer _will arrive_ at the correct instructions, and given the instruction compatibility and overlap with the 65816, it will run them. In native mode, however, our registers are all _twice as large_, so the code will start to mangle RAM and cause the GS to crash to monitor (the ROM contains a small assembler/monitor that is invoked during a crash). Then, even if the computer were to execute these instructions successfully (and display the char), the `jsr` used to exit the routine will jump to a 16-bit address, so if bank boundaries were crossed, you will _never_ get back to your code. We would need a native IIgs ROM `COUT` (which, I do not believe exists for the 40-char video page).

### Displaying a character

So, we're still left with the task of displaying a character. It looks like we're going to have to get our hands dirty and write the routine ourselves. The bank 0 map above has addresses `$CFFF->$C000` marked as I/O. On the IIgs, this specifically means locations allowing you to:

- Read the keyboard (important to us)
- Softswitches to mode set to text, high-res, and SHR "super-high-res" video pages (important to us)
- Invoke `lda` on the speaker to cause a tick
- Read the game controller

The first two points are of value to us. We'll visit reading the keyboard a little bit later, because it feels easier to load the immediate value of a character to a register for testing if it works. Let's take a look at the video page layout. It is located in RAM bank 0.

![vplayout](https://i.imgur.com/gNrUJQR.png)

The 16-bit addresses listed in the table above are all _only available_ on bank 0. If we write values (in this case, char codes) to the text pages, they will appear on the display. The 65816's 24-bit addressing allows us to write to any 24-bit address, which means that we now have enough information to write a simple program that lets us print a character to the display. Well, almost. By default (or so it seems during my testing), GS/OS loads a program in 80 character video mode, so we need to toggle the video softswitches before printing. We'll get to that in a later section. For now, just assume that we've already toggled the appropriate switches. Then, the code required to display a character would look as such:


```asm
  lda #"D" ; the assembler will substitute with the appropriate char code
  stal $000400
```

However, this is _still_ incorrect. We used the `A` register to store our character, then the `stal` command with a long 24-bit address to the first position of the 40 character text page. The `A` register of the 65816 in native mode is 16 bits, or two bytes large. A character is only one byte, so our write in this case writes _two_ characters to the page (depending on what is left in the other half of the `A` register when the write is performed). It is possible to operate on two characters at a time with `ldal #"AB"`, but reading one key at a time while having to write two characters is going to be an irritating exercise. Recall that we discussed a 6502 emulation mode that involved telling the 65816 to use smaller registers. It is _also possible_ to change the size of the registers without exiting native mode. That means we can change the size of `A` to be 8 bits, such that `stal` performs an 8 bit write (or one char). This piece of the puzzle is complete, but in order to figure out how to get this code to do what we want it to, we need to understand the processor status register.

### The processor status register and softswitches

![psr](https://i.imgur.com/NE1QJ6w.png)

For the assembly programmer, this is a _magnificent_ place to be. Look at all the information you can represent with just 8 bits! Instructions like `bcc` ("branch if carry clear") leverage this register for branching logic. Other instructions like `cmp` set these bits to give you some information about the operation you performed. In `cmp`'s case, the carry bit is set if `A` is greater than the other operand. The `E` bit is the emulation bit, but we won't be touching it for this tutorial since this editor will remain 16-bit native. 

In our case, we need to set the "Memory/Accumulator Select" to `1` such that it is then 8 bits wide. To do this, we can write to this register in the following manner. If not apparent, the hexadecimal number used in the instruction below is 8 bits large and represents the entire width of the register. Additionally, the 65816 is little-endian, so keep that in mind when comparing the number to the register!

```asm
  sep $20 ; set processor bits
```

To return back to full width:

```asm
  rep $20 ; reset processor bits
```

Recall that earlier we mentioned that softswitches in the I/O block were used to change video modes. We still need to place the GS into the 40 character video mode, so let's do that. Softswitches can be toggled by either performing an `lda` or `sta` to the address of the switch. Consult an Apple IIgs hardware reference for all switches in the I/O block. In our case, you can imagine that some kind of video controller listens at these addresses for a signal to do something. 

You _MUST_ be in 8-bit accumulator mode for this to work. For example, `$C00C` disables the 80 char hardware but `$C00D` enables it. If you write a 16-bit value to `$C00C` it will also overwrite `$C00D`, therefore turning it off and then immediately back on again. Ask me how I know!

Let's combine everything we have so far, and add the softswitch toggling code to make a simple and imperative hello world program. We now have assembled almost all of the pieces necessary to start building our text editor.

```asm
  sep $20
  stal  $00C000     ; disable 80 column store
  stal  $00C00C     ; disable 80 column hardware
  stal  $00C050     ; set standard apple ii gfx mode
  stal  $00C051     ; select text mode only. "only"?
  ldal  $00C054     ; select text page 1 (there are 2)

  lda #"O"
  stal $000400
  lda #"H"
  stal $000401
  lda #"A"
  stal $000402
  lda #"I"
  stal $000403
```

![ohai](https://i.imgur.com/xYTz7Sm.png)

### Reading the keyboard

Our remaining challenge is to figure out how to capture user input. After consulting the [IIgs hardware reference](http://www.goldstarsoftware.com/applesite/Documentation/AppleIIgsHardwareReferenceManual.PDF), we obtain some useful I/O locations:

- `$C000` contains the character code of the key that was pressed and the _strobe bit_
- `$C010` contains the any-key down flag and the _strobe reset_ softswitch

Recall that earlier we mentioned that a character code can fit within one byte (or 8 bits). Imagine now that I have just pressed the F key and immediately performed a `ldal $00C000`. The `A` register would look like this:

| Strobe (7) | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|------------|---|---|---|---|---|---|---|
| 1          | 1 | 1 | 0 | 0 | 1 | 1 | 0 |

Bits 0-6 represent the character code `$C6`, and bit 7 is the strobe. What is this strobe bit anyway, and why is it there? The keyboard controller sets the strobe to give the programmer a mechanism of understanding when a keydown event has happened. Some may say "I don't need a strobe bit to do this, can't I just check to see if the value changes?" What if the user intentionally inputs the same character twice? Additionally, you would have to waste an extra byte to store the previously inputted value if you wish to employ this method. The strobe bit provides a much more elegant solution to this problem, and furthermore, we control the entire feedback loop by being able to clear it, which then tells the keyboard controller that it is OK to poll for another keydown event and modify the data available at `$C000` once more. When the strobe bit is set, the keyboard controller will _not_ overwrite that location!

Logic is best written with pen on paper, so let's come up with a small event loop:

- Read character data from `$C000`
- Determine if the strobe bit is set 
  - If yes, branch and handle input
  - If not, proceed
- Read `$C010`, thereby toggling a softswitch causing the strobe bit to clear

Now, in 65816, this logic looks like this:

```asm
:begin ldal $00C000
       bit %1
       bmi :handlekey
       ldal $00C010
       jmp :begin
```

The `bit` instruction sets the `n` bit of the processor status register to the high bit of the data in the accumulator. Conveniently for us, this means that we can use the `bmi` instruction ("branch if minus") immediately after, which branches only if the `n` bit is high (i.e. set to `1`). Success! We've assembled all the knowledge we need to make a very basic text editor for the Apple IIgs.
