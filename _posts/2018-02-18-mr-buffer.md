---
title: How to write a text editor for a 31 year old computer
published: false
layout: post
categories: retro
date: 2018-02-18gT23:48:53.000Z
---

The Apple IIgs came out on September 15, 1986. It featured an absolutely earth-shattering 2.8 MHz WDC 65816 CPU (the same one that powered the SNES and other similar computers of that era, a 16-bit CPU with 24-bit addressing), 256k or 1MB RAM (upgradable to 8 MB), and an Ensoniq 8-bit stereo synth (which was a welcome upgrade from the bit-speaker of the Apple II family). The original Apple II family was built around the 6502 (8 bit, 16-bit addressing): it was designed to use console-interactive applications via ProDOS, or games that had their own custom rendering stacks built from scratch. In contrast, GS shipped with GS/OS, an operating system built to use the new computer's more powerful hardware. Booting the GS off of its system disk brought you to a GUI and not a console prompt. It would be misleading to omit mention of the [Apple built GUI](http://toastytech.com/guis/a2desk.html) for the Apple II family, however this compared to GS/OS is more of an afterthought. This was the first consumer-first computer that Apple shipped with _intent_ to provide a graphical user experience (other than the Lisa, but that computer was primarily marketed to businesses) to the everyman. This article is going to walk through, start to finish, how to build a text editor for this machine. 

### What do we have to work with?

At the beginning of this project I imposed a few requirements. My text editor should:

- Be launchable from GS/OS regardless of whether or not it actually runs windowed in the operating system.
- Not occupy more than 256k of RAM, so that it may run on _any_ IIgs.
- Run in native 16-bit mode.

If you are unfamiliar with this processor, then the last bulletpoint is confusing. By the time the IIgs had launched, there was already a plethora of software out in the wild that was compatible with the original Apple II (which used the 6502). The 65816 has an "emulation mode" that can be toggled which effectively turns the '816 into a 6502 by selectively "halving" the width of its accumulator and index registers (amongst some other things, which we will cover later).

GS/OS is a 16-bit co-operatively multitasked operating system. For me, this means that my text editor is going to be the only running program on the system after it finishes loading. The OS will remain in RAM but I will have to abstain from writing to certain memory locations in order to not corrupt the OS code. GS/OS will bootstrap my program and then pass complete control of the computer to it. To quit the application, I have to jump (`jsl` in native mode) to the entry point of the OS where it will then take over. 

Insofar as programming environment our options look kind of bleak:

- [ORCA/C](https://github.com/byteworksinc/ORCA-C), ANSI C compiler, but must run on bare metal or emulator.
- [cc65](https://github.com/cc65/cc65), ANSI C compiler, but only for 6502.
- [Merlin16](https://en.wikipedia.org/wiki/Merlin_(assembler)), a 65816 assembler, but must run on bare metal or emulator.
- [Merlin32](https://www.brutaldeluxe.fr/products/crossdevtools/merlin/), a Merlin16 macro compatible assembler that runs on any modern computer that can build it from source.

I own a physical IIgs, but wanted to be able to develop easily from my computer. Furthermore, building _inside_ of an emulator is also clunky and not something that can easily be automated with a build script (i.e. it is not a good use of time to hack the emulator such that I can script UI actions), so the only viable option was to use Merlin32. Additionally, the only way for me to really deploy things to the physical computer is by air-gapping a CF card to my desktop which is the only computer here with a multi-card reader. After deciding on Merlin32, the first order of business was to figure out how to write disk images with my program such that an emulator could load it. I had to [write POSIX fs bindings](https://github.com/mach-kernel/cadius) for the BrutalDeluxe imaging tool, since it only ran on Windows, which is some kind of cardinal sin. Judicious use of `#pragma once` and some `stat()` had me making Apple II disk images from any popular `*nix` flavor. It was _finally_ time to get some programming done.

### Displaying a character

The only way to not lose your mind with difficult projects is to try to write your software in as much of a goal-oriented manner as possible. The _bare minimum_ feature that _any_ editor must be able to implement is the display of strings on screen. In most programming languages, you can invoke some variant of `print()` to accomplish this task. In Apple II world, we do not have this affordance, although this is somewhat a lie since the Apple II ROM contains a series of toolbox functions that implement `COUT`, `RDKEY` and numerous other utilities. The workflow for toolbox utilities is simple: you prepare the registers with some data (in the case of `COUT`, a character is loaded to the `A` register, called the "accumulator"), `jsr` to the routine from your program, it performs some arbitrary task, and then invokes `rts` to return control to your code. This seems to be exactly what we would want, so why can't we use it?

It is time to learn a little bit about Apple IIgs memory architecture.

![iigsmemmap](https://i.imgur.com/K2wCCDW.png)

GS/OS executable files are stored in OMF, a relocatable executable format. If you've written software for Linux and/or Windows, then this is something analog to your `ELF` or `PE32` executable formats, but for the GS operating system. Regardless, it's important to note that the binary we are to produce is _relocatable_. This means that the operating system can arbitrarily load your code anywhere in free built-in or auxiliary RAM. Observe that each chunk of memory flows `$FFFF->$0000`, but more explicitly, that the memory is divided into 64k chunks. Bank `$00` is special ([also for hardware reasons best explained here](https://retrocomputing.stackexchange.com/questions/52/how-do-i-use-shadowed-memory-to-render-super-hi-res-quickly), but we are skipping this for today), as it contains access to the computer's ROM. Below is a diagram of the bank `$00` layout.

![bank0](https://i.imgur.com/OHRysCb.png)

Recall that earlier we spoke about using `jsr` to invoke the `COUT` routine after loading a character. The `jsr` instruction takes a 16-bit address as an immediate argument, which specifically means that you cannot jump across banks. Since our GS/OS code is relocatable, you _do not have any guarantee_ 